!    Compute Pyridine - He interacton energy
!    Copyright Christian Henriksen 2015, 2020
!    Based on work by Cybulski, Henriksen and Fernandez
!
!    See
!      Cybulski, Henriksen, Fernandez: 
!      Theoretical Study of the Pyridineâ€“Helium van der Waals Complexes
!      https://doi.org/10.1021/acs.jpca.5b08492
!
!    This program is free software: you can redistribute it and/or modify
!    it under the terms of the GNU Lesser General Public License v3.0
!    as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.



function PyridineHePot(x) result(u)
    ! This function computes an approximation of the interaction energy
    ! between a Helium atom placed at the input parameter x in R^3,
    ! and Pyridine. The latter molecule is placed so that the
    ! Carbon atoms are in the x-y plane, the center of mass is at the origin
    ! and so that there is symmetry with respect to reflection in the
    ! y-axis. 
    !   The interaction is found by evaluating a fit.
    ! We number the N and C - atoms from 1 to 7 as follows:
    !
    !          C   5
    !       /     \\
    !  6  C         C   4
    !     ||        |
    !  7  C         C   3
    !       \    //
    !          N   1 and 2
    !
    ! and the H atoms with the numbers 3, 4, 5, 6, 7
    ! such that H i bonds with C i .
    ! We put effective positions determined by the parameter s (unit-less).
    ! If s = 0 we put C_i equal to the position of the i'th nucleus.
    ! If s = 1 we put C_i equal to the position of H_i for i = 3, 4, ..., 7 
    ! and for i = 1, 2 we put C_i to the position of the Nitrogen nuc,
    ! For 0 < s < 1 we interpolate C_i = C_i(s) linearly.
    ! Given the parameter dil (A) Let
    !  d_i = || x - C_i || / dil, when i = 1, 2, ..., 7
    ! Then the approximation is computed as
    !  u = Sum_{e in Ex} (1/12 * lc[e] * 
    !       Sum_{g in grp} D_1^e(g(1)) * D_2^e(g(2)) * ... * D_7^e(g(7))),
    ! where we let D_i = 10 * e^(-d_i),
    ! and grp is the group of permutations of {1, 2, ..., 7} generated by
    ! (2, 3, 4, 5, 6, 7)  (rotation of the ring) 
    ! (3 7)(4 6)          (reflection in the y axis)
    ! In particular, grp has order 12 and is isomorphic to the dihedral
    ! group D_6. 
    !   E.g., letting e = [0, 1, 0, 0, 0, 0, 0],
    ! then the sum in the second line in the expression for u equals
    !  2 * (D_2 + D_3 + D_4 + ... + D_7) ,
    ! whereas with e = [1, 0, 0, 0, 0, 0, 0],
    ! the sum equals
    !  12 * D_1 = 12 * D_2 .
    !
    ! The subroutine
    !  1) First declares variables
    !  2) Then initializes parameters
    !  3) And finally computes u.


    implicit none

    !
    ! 1) Declaration of variables
    !
    integer, parameter :: dp = kind(1d0)
    real (kind=dp) :: u
    real (kind=dp), dimension(3), intent(in) :: x

    ! Constants
    integer, parameter :: natoms = 7 ! Number of atoms in molecule.
    real (kind=dp) :: x_mol(natoms, 3) ! Atom positions in the molecule.
    real (kind=dp), parameter :: dil  = 1.765030587370d0 
    real (kind=dp), parameter :: s = 0.503690735135d0 ! expansion 
    integer, parameter :: nlin = 34 ! Number of linear coefficients
    integer, dimension(natoms, nlin) :: term_index
    integer, parameter :: max_degree = 6
    real (kind=dp), dimension(nlin) :: lc ! the linear coefficients

    ! Permutations
    integer, parameter :: nperms = 12 ! number of permutations in the group
    integer, dimension(natoms, nperms) :: grp 
    ! the group of permutation that act on the indexes

    ! For computing distances we use the variables
    real (kind=dp), dimension(natoms, 3) :: x_eff, x_ext
    real (kind=dp), dimension(natoms) :: dists
    real (kind=dp), dimension(natoms, 3) :: dx

    ! To sum the terms
    real (kind=dp), dimension(natoms, 0:max_degree) :: bt
    real (kind=dp) :: t, term_sum

    ! To store the permutations (by grp) of term_indexes we have    
    integer, dimension(natoms, nperms) :: indexes 

    ! And some counters for loops
    integer :: i, j, k, p

    !
    ! 2) Initialization
    ! 
    ! The positions of the carbons in the molecule
    x_mol(1, :) = (/ 0.0000000000d0,   -1.3922394839d0,   0.0d0 /)
    x_mol(2, :) = (/ 0.0000000000d0,   -1.3922394839d0,   0.0d0 /)
    x_mol(3, :) = (/ 1.1401260741d0,   -0.6927479105d0,   0.0d0 /)
    x_mol(4, :) = (/ 1.1953321023d0,    0.6999583400d0,   0.0d0 /)
    x_mol(5, :) = (/ 0.0000000000d0,    1.4125171313d0,   0.0d0 /)
    x_mol(6, :) = (/-1.1953321023d0,    0.6999583400d0,   0.0d0 /)
    x_mol(7, :) = (/-1.1401260741d0,   -0.6927479105d0,   0.0d0 /)

    ! The effective positions when s = 1 
    x_ext(1, :) = (/ 0.0000000000d0,   -1.3922394839d0,   0.0d0 /)
    x_ext(2, :) = (/ 0.0000000000d0,   -1.3922394839d0,   0.0d0 /)
    x_ext(3, :) = (/ 2.0568776762d0,   -1.2758844614d0,   0.0d0 /)
    x_ext(4, :) = (/ 2.1525393477d0,    1.2057038186d0,   0.0d0 /)
    x_ext(5, :) = (/ 0.0000000000d0,    2.4943173072d0,   0.0d0 /)
    x_ext(6, :) = (/-2.1525393477d0,    1.2057038186d0,   0.0d0 /)
    x_ext(7, :) = (/-2.0568776762d0,   -1.2758844614d0,   0.0d0 /)

    

    ! The indexes/exponents in the terms
    term_index(:,   1) = (/ 0, 0, 0, 0, 0, 0, 2 /)
    term_index(:,   2) = (/ 0, 0, 1, 0, 1, 0, 1 /)
    term_index(:,   3) = (/ 1, 0, 0, 0, 0, 0, 2 /)
    term_index(:,   4) = (/ 3, 0, 0, 0, 0, 0, 0 /)
    term_index(:,   5) = (/ 0, 0, 0, 0, 0, 1, 3 /)
    term_index(:,   6) = (/ 0, 0, 0, 0, 0, 2, 2 /)
    term_index(:,   7) = (/ 0, 0, 0, 0, 2, 0, 2 /)
    term_index(:,   8) = (/ 0, 0, 0, 1, 0, 2, 1 /)
    term_index(:,   9) = (/ 2, 0, 0, 0, 0, 1, 1 /)
    term_index(:,  10) = (/ 2, 0, 0, 0, 1, 0, 1 /)
    term_index(:,  11) = (/ 0, 0, 0, 0, 0, 0, 5 /)
    term_index(:,  12) = (/ 0, 0, 0, 0, 1, 0, 4 /)
    term_index(:,  13) = (/ 0, 0, 0, 0, 1, 2, 2 /)
    term_index(:,  14) = (/ 0, 0, 0, 0, 1, 3, 1 /)
    term_index(:,  15) = (/ 0, 0, 0, 1, 0, 0, 4 /)
    term_index(:,  16) = (/ 0, 0, 0, 1, 0, 2, 2 /)
    term_index(:,  17) = (/ 0, 0, 0, 2, 0, 0, 3 /)
    term_index(:,  18) = (/ 0, 0, 0, 2, 0, 1, 2 /)
    term_index(:,  19) = (/ 4, 0, 0, 0, 0, 0, 1 /)
    term_index(:,  20) = (/ 5, 0, 0, 0, 0, 0, 0 /)
    term_index(:,  21) = (/ 0, 0, 0, 0, 0, 0, 6 /)
    term_index(:,  22) = (/ 0, 0, 0, 0, 0, 1, 5 /)
    term_index(:,  23) = (/ 0, 0, 0, 0, 1, 0, 5 /)
    term_index(:,  24) = (/ 0, 0, 0, 0, 1, 1, 4 /)
    term_index(:,  25) = (/ 0, 0, 0, 0, 2, 2, 2 /)
    term_index(:,  26) = (/ 0, 0, 0, 0, 3, 0, 3 /)
    term_index(:,  27) = (/ 0, 0, 0, 1, 0, 0, 5 /)
    term_index(:,  28) = (/ 0, 0, 0, 1, 0, 1, 4 /)
    term_index(:,  29) = (/ 0, 0, 0, 1, 0, 2, 3 /)
    term_index(:,  30) = (/ 0, 0, 0, 1, 0, 3, 2 /)
    term_index(:,  31) = (/ 0, 0, 0, 1, 3, 0, 2 /)
    term_index(:,  32) = (/ 1, 0, 0, 0, 2, 0, 3 /)
    term_index(:,  33) = (/ 2, 0, 0, 1, 0, 0, 3 /)
    term_index(:,  34) = (/ 6, 0, 0, 0, 0, 0, 0 /)

    ! The linear coefficients
    lc( 1) =  -39.5778687121d0
    lc( 2) =  -54.8669495456d0
    lc( 3) =   22.3308768653d0
    lc( 4) =  -6.82205298965d0
    lc( 5) =  -273.771896098d0
    lc( 6) =   264.290465181d0
    lc( 7) =  -834.948294382d0
    lc( 8) =   929.316332073d0
    lc( 9) =  -42.6836941959d0
    lc(10) =   56.9186701999d0
    lc(11) =  -117.262490527d0
    lc(12) =   291.861222402d0
    lc(13) =  -359.679398663d0
    lc(14) =   530.305807143d0
    lc(15) =   375.195782124d0
    lc(16) =  -1356.44857786d0
    lc(17) =  -2043.09197673d0
    lc(18) =   2535.53531729d0
    lc(19) =  -46.5811912318d0
    lc(20) =   27.3150788609d0
    lc(21) =   191.029707414d0
    lc(22) =   -278.87993927d0
    lc(23) =  -697.226857781d0
    lc(24) =   942.313367616d0
    lc(25) =  -785.885962908d0
    lc(26) =   310.517544747d0
    lc(27) =  -1043.85349337d0
    lc(28) =   3603.70456132d0
    lc(29) =   -4036.3585235d0
    lc(30) =   2492.18149421d0
    lc(31) =  -681.840794794d0
    lc(32) =   213.640300619d0
    lc(33) =  -140.319643467d0
    lc(34) =   3.31170255294d0

    ! We define a group of permutations of the numbers
    ! from 1, 2, ..., 8 corresponding to each C-atom in the
    ! molecule.
    grp(:, 1)  = (/ 1, 2, 3, 4, 5, 6, 7 /)
    grp(:, 2)  = (/ 1, 3, 4, 5, 6, 7, 2 /) 
    grp(:, 3)  = (/ 1, 4, 5, 6, 7, 2, 3 /)
    grp(:, 4)  = (/ 1, 5, 6, 7, 2, 3, 4 /)
    grp(:, 5)  = (/ 1, 6, 7, 2, 3, 4, 5 /)
    grp(:, 6)  = (/ 1, 7, 2, 3, 4, 5, 6 /)
    grp(:, 7)  = (/ 1, 2, 7, 6, 5, 4, 3 /)
    grp(:, 8)  = (/ 1, 7, 6, 5, 4, 3, 2 /)
    grp(:, 9)  = (/ 1, 6, 5, 4, 3, 2, 7 /)
    grp(:, 10) = (/ 1, 5, 4, 3, 2, 7, 6 /)
    grp(:, 11) = (/ 1, 4, 3, 2, 7, 6, 5 /)
    grp(:, 12) = (/ 1, 3, 2, 7, 6, 5, 4 /)

    !
    ! 3) Computing u
    !

    ! We compute the effective positions
    x_eff = (1.0d0 - s) * x_mol + s * x_ext
    
    ! and then the distances divided by dil .
    do k = 1, natoms
        dx(k, :) = (x_eff(k, :) - x) ** 2 
        dists(k) = sqrt(dx(k, 1) + dx(k, 2) + dx(k, 3)) / dil
    end do

    ! then the baseterms: the monomials to different powers
    do i = 1, natoms
        do j = 0, max_degree
            bt(i, j) = exp((log(10.0d0) - dists(i)) * j)
        end do
    end do
    ! Now we have
    !  bt(i, j) = D_i ^ j, where
    !  D_i = 10^(-d_i) and
    ! d_i denotes the modified distance from x to the i'th atom in the
    ! pyridine molecule. So d_i is equal to dists(i)

    ! The main part that computes the approximation.
    u = 0.0
    do i = 1, nlin

        ! We compute the permutations of the i'th term_index
        ! and store the result in indexes
        do p = 1, nperms
            do k = 1, natoms
                indexes(k, p) = term_index(grp(k, p), i)
            end do
        end do

        term_sum = 0.0
        do j = 1, nperms ! computes the term_sum, summing over the 
                         ! permutations
            t = 1.0
            do k = 1, natoms ! computes the product of monomials
                t = t * bt(k, indexes(k, j))
            end do
            term_sum = term_sum + t
        end do
        u = u + lc(i) * term_sum / nperms
    end do

end function PyridineHePot
